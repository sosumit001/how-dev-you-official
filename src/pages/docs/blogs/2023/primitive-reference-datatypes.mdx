import Blogheader from '../../blogComponents/blog-header/Blogheader'
import Image from '../../blogComponents/blog-image/Image'
import Highlighter from '../../blogComponents/blog-syntax-highlighter/Highlighter'
import Blognote from '../../blogComponents/blog-imp-note/Blognote'


{/* images */}
import primitive_and_reference_01 from './assets/primitive-and-reference/primitive-and-reference-01.png'

import primitive_and_reference_02 from './assets/primitive-and-reference/primitive-and-reference-02.png'

import primitive_and_reference_03 from './assets/primitive-and-reference/primitive-and-reference-03.png'

{/* blog - header */}
<Blogheader 
heading = {"Primitive and Reference types"}  
date = {"Nov 1, 2023"}
/>

JavaScript uses two types: primitive (simple data) and reference (objects, which are memory references). Unlike some languages, JavaScript treats primitives like references. It manages variables using a variable object, storing primitives directly and referencing objects' memory locations. Despite initial similarities, primitives and references behave differently. Many other distinctions exist between them

<Image 
src = {primitive_and_reference_01}
alt = "datatypes in javascript"
/>

# Primitive Types

Primitive types in JavaScript are basic data like true, <i>12</i>, or <i>'cat'</i>. There are five: 

<i>Boolean</i> (true or false),

<i>Number</i> (any whole or decimal number), 

<i>String</i> (text in quotes), 

<i>Null</i> (represents nothing), 

<i>Undefined</i> (represents no value, often given to a variable before it's used).

The first three types (Boolean, Number, String) act similarly, while the last two (Null and Undefined) are a bit different. Each type can be written directly without using a variable, like writing down a name or price. Here are examples of each type in their simple form

<Highlighter
	codeString={`// strings
let name = "Alex", selection = "a"
// numbers
let count = 25, cost = 1.51
// boolean
let found = true
// null
let object = null
// undefined
let flag, ref // Both flag and ref are automatically assigned undefined
`}
language="javascript"
/>

In JavaScript, when you store a primitive in a variable, it directly holds the value, not a reference to an object. So, if you assign a primitive to a variable, a copy of the value is made. This means if you have two variables, each has its own independent copy of the data
<Image 
src = {primitive_and_reference_02}
alt = "primitive types memeory view"
/>

<Highlighter 
	codeString = {`// Storing a primitive value
let num1 = 10 // num1 contains the value 10
let num2 = num1 // num2 now contains a copy of the value 10

// Changing num2 does not affect num1
num2 = 20

console.log(num1) // Output: 10
console.log(num2) // Output: 20
`}
	language = "javascript"
/>

## Identifying Primitive Types

The easiest way to check a variable's type is to use <i>typeof</i>. It's a built-in operator that works with <i>strings, numbers, Booleans, and undefined</i>. Here's what you get when you use typeof with different primitive values

<Highlighter 
	codeString = {`console.log(typeof "Alex") // Outputs: "string"
console.log(typeof 10) // Outputs: "number"
console.log(typeof 5.1) // Outputs: "number"
console.log(typeof true) // Outputs: "boolean"
console.log(typeof undefined) // Outputs: "undefined"
`}
	language = "javascript"
/>

Many developers find the result of <i>console.log(typeof null)</i> puzzling. It returns "object" instead of "null". This is recognized as a mistake by the committee that designs JavaScript. While you might think of null as an empty object pointer, it's still a confusing result.

A better way to check if a value is null is to directly compare it to null, like this

<Highlighter
	codeString  = {`console.log(value === null)   // true or false`}
	language = "javascript"
/>

<Blognote
	heading = "Strict Type Comparison"
	text = {`Here, the code employs the triple equals operator (===) rather than 
	the double equals operator. The key distinction is that the triple equals operator performs the comparison without attempting to convert the variable into another type`}
/>

## Primitive methods

In spite of being considered primitive types, strings, numbers, and Booleans possess methods. However, it's worth noting that the null and undefined types lack methods. Strings, in particular, offer a wide array of methods to assist you in manipulating them. For instance

<Highlighter 
	codeString = {`let name = "Alex"
let lowercaseName = name.toLowerCase() // converts to lowercase
let firstLetter = name.charAt(0) // retrieves the first character
let middleOfName = name.substring(2, 5) // retrieves characters 2-4
let count = 10
let fixedCount = count.toFixed(2) // converts to "10.00"
let hexCount = count.toString(16) // converts to "a"
let flag = true
let stringFlag = flag.toString()"
`}
	language = "javascript"
/>

# Reference Types

Reference types in JavaScript are like classes, representing objects. Reference values, synonymous with objects, are instances of these types. An object is an unordered list of properties with names (strings) and corresponding values. When a property holds a function, it's called a method. Functions themselves are reference values, so there's little difference between properties holding arrays or functions, except functions can be executed

## Building Objects

Think of JavaScript objects like labeled storage boxes, where you can put whatever you want with some label for that thing, cool isn't it.

 To create an object, you can use a special function called a constructor, which is just a way to make objects. Constructors usually start with a capital letter. For example, if you use a constructor called 'Object', you can create a new object and save it as 'object'.

for example 
<Highlighter
	codeString = {`var object1 = new Object()
var object2 = object1`}
	language = "javascript"
/>

This code makes a new object and calls it 'object1'. Then, 'object2' is set to be the same as 'object1'. There's only one object made in the beginning, but now both 'object1' and 'object2' refer to that same object

Let me tell you what I'm talking about with following diagram : 

<Image 
src = {primitive_and_reference_03}
alt = "memory in reference types"
/>

Now with following <i>array</i> example everything would be clear to you that how manipulating array data structure with one instance is reflected in another 

<Highlighter 
	codeString = {`// Create an array and assign it to 'array1'
var array1 = [1, 2, 3]

// Assign the value of 'array1' to 'array2'
var array2 = array1

// Modify 'array1'
array1.push(4)

// it will reflect the modification
console.log(array2) // [1, 2, 3, 4]
`}
	language = "javascript"
/>

## Built-in Types

You've learned how to create and work with basic objects using new Object(). The Object type is just one of several built-in reference types available in JavaScript. The other built-in types serve specific purposes and can be created when needed. These types include:

Array: A list of values with numerical indices

<i>Date</i>  ( Represents a date and time )

<i>Error</i>  ( Represents a runtime error )

<i>Function</i> ( Defines a function ) 

<i>Object</i>  ( Represents a general-purpose object )

<i>RegExp</i> ( Represents a regular expression )

## Literal froms
Literal Forms simplify creating reference values. They let you define values directly without the need for object creation using 'new' and a constructor.
### Object and Function Literals
To create an object with object literal syntax, you can define the properties 
of a new object inside braces
<Highlighter
	codeString = {`var book = {
 name: "The Principles of Object-Oriented JavaScript",
 year: 2014
}`}
/>

You almost always define functions using their literal form. In fact, using the Function constructor is typically discouraged given the challenges of maintaining, reading, and debugging a string of code rather than actual code, so you’ll rarely see it in code.

<Highlighter 
	codeString = {`// Function literal
let addLiteral = function(a, b) {
    return a + b
}
// Function constructor form (less common and not recommended)
let addConstructor = new Function('a', 'b', 'return a + b')
	`}
/>

## Identifying Reference Types

Identifying functions is straightforward: using the typeof operator on a function should return "function"

<Highlighter 
	codeString = {`function reflect(value) {
  return value
}
console.log(typeof reflect) // "function"`}
/>
However, for other reference types, typeof returns "object", which isn't very helpful when dealing with various types. To identify reference types more accurately, you can use JavaScript’s instanceof operator.

The instanceof operator takes an object and a constructor as parameters. It returns true if the object is an instance of the specified type otherwise, it returns false

<Highlighter 
	codeString = {`var items = []
var object = {}

console.log(items instanceof Array) // true
console.log(object instanceof Object) // true
console.log(reflect instanceof Function) // true
`}
/>

## Identifying Arrays
Sometimes, web developers face a tricky situation when dealing with arrays. JavaScript values can move between frames in a web page. But, each frame has its own 'version' of basic types like Object or Array.

This causes a small hiccup. The usual way to check types, 'instanceof', doesn't work when passing arrays between frames. It thinks it's a different type.

To solve this, ECMAScript 5 introduced a helpful tool called 'Array.isArray()'. It's like a magic wand that says 'yes, this is definitely an array', no matter where it came from

<Highlighter 
codeString = {`var items = [];
console.log(Array.isArray(items)) // true
`}
/>

# Key Takeaways

JavaScript doesn't use classes like some other languages, but it does have different types for data. There are primitive types (simple values like strings, numbers, Booleans, null, and undefined) that are stored directly in the variable.

For more complex data, there are reference types. Objects are examples of reference types. You can create new objects with new or a reference literal. You access properties and methods using dot or bracket notation.

Functions are special objects in JavaScript. You can identify them using typeof.

To identify objects of other reference types, use instanceof with a constructor.

JavaScript makes primitives act more like references with String, Number, and Boolean wrapper types. They let you treat primitives like objects temporarily.

Creating your own instances of these wrapper types can be confusing, so it's usually best to avoid it






